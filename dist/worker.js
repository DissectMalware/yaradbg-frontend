/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/hex_exp_worker.js":
/*!**********************************!*\
  !*** ./src/js/hex_exp_worker.js ***!
  \**********************************/
/***/ (() => {

eval("if( 'function' === typeof importScripts) {\r\n\r\n    // self.importScripts(\"/yaradbg-frontend/src/js/operators.js\")\r\n\r\n    self.onmessage = function (e) {\r\n        data = e.data\r\n        res = match_rule(data.file, data.rule)\r\n        self.postMessage(res);\r\n    }\r\n\r\n    function match_rule(file, rule) {\r\n        let evaluated_rule = {strings: new Map(), condition: []}\r\n\r\n        Object.keys(rule).forEach(function (key) {\r\n\r\n            if (key == 'string') {\r\n                match_strings(rule[key], file, evaluated_rule.strings)\r\n            } else if (key == 'condition') {\r\n                eval_condition(file, rule[key], evaluated_rule)\r\n            }\r\n        });\r\n\r\n        return evaluated_rule\r\n    }\r\n\r\n\r\n    function match_strings(strings, file, rule_result) {\r\n\r\n        let matches = null\r\n        for (let i = 0; i < strings.length; i++) {\r\n            rule_result.set(strings[i].str_name.slice(1), [])\r\n        }\r\n        for (const index in strings) {\r\n            let string = strings[index]\r\n\r\n            if (string.type == 'hex_exp_bytecode' ||\r\n                string.type == 'regex_expression_bytecode') {\r\n                matches = find_all(file, string.val)\r\n                if (matches != null) {\r\n                    for (let i = 0; i < matches.length; i++) {\r\n                        rule_result.get(string.str_name.slice(1)).push({\r\n                            string: string,\r\n                            start: matches[i].start,\r\n                            end: matches[i].end\r\n                        })\r\n                    }\r\n                }\r\n            } else if (string.type == 'literal_string') {\r\n\r\n                let nocase = false,\r\n                    ascii = false,\r\n                    wide = false;\r\n                for (let i = 0; i < string.modifiers.length; i++) {\r\n                    switch (string.modifiers[i].modifier) {\r\n                        case 'nocase':\r\n                            nocase = true;\r\n                            break\r\n                        case 'ascii':\r\n                            ascii = true;\r\n                            break\r\n                        case 'wide':\r\n                            wide = true;\r\n                    }\r\n                }\r\n                if (wide == false)\r\n                    ascii = true\r\n\r\n                let bytecode = []\r\n                string.val = string.val.substr(1, string.val.length - 2)\r\n\r\n                for (let i = 0; i < string.val.length; i++) {\r\n                    bytecode.push(`chr ${string.val.charCodeAt(i).toString(16)}`)\r\n                }\r\n                bytecode.push('match')\r\n\r\n                matches = find_all(file, bytecode)\r\n                if (matches != null) {\r\n                    for (let i = 0; i < matches.length; i++) {\r\n                        rule_result.get(string.str_name.slice(1)).push({\r\n                            string: string,\r\n                            start: matches[i].start,\r\n                            end: matches[i].end\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return matches\r\n    }\r\n\r\n    function find_all(file_content, regex_bytecode) {\r\n        let index = 0\r\n        let matches = []\r\n        let match = null\r\n\r\n        let instructions = get_instructions(regex_bytecode)\r\n        let parts = []\r\n        let has_start_mask, has_end_mask;\r\n        var lookahead = null\r\n\r\n        if (instructions[0][0] == 'chr')\r\n            lookahead = instructions[0][1]\r\n\r\n        let thread_pool = []\r\n        for (let i = 0; i < 10; i++) {\r\n            thread_pool.push({pc: 0, priority: 0})\r\n        }\r\n\r\n        let start = performance.now()\r\n        while (index < file_content.length) {\r\n            match = find(file_content, instructions, index, thread_pool)\r\n            if (match != null) {\r\n                index = match.start + 1\r\n                matches.push(match)\r\n            } else {\r\n                break\r\n            }\r\n        }\r\n        let end = performance.now()\r\n        let diff = (end - start).toString()\r\n\r\n        return matches\r\n    }\r\n\r\n    function get_instructions(bytecode) {\r\n        debugger;\r\n        let instructions = []\r\n        let lines = bytecode\r\n        let has_start_mask = false\r\n        let has_end_mask = false\r\n        let parts = null\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n            parts = lines[i].split(/[ ,]/)\r\n            if (parts[0] == 'chr') {\r\n                has_start_mask = parts[1].startsWith('?') ? 0 : 0x0f\r\n                has_end_mask = parts[1].endsWith('?') ? 0 : 0xf0\r\n                parts[1] = parseInt(parts[1].replace('?', '0'), 16)\r\n                parts.push(has_end_mask | has_start_mask)\r\n            } else if (parts[0] == 'chrc') {\r\n                for (let i = 1; i < parts.length; i++) {\r\n                    parts[i] = parseInt(parts[i], 16)\r\n                }\r\n            } else if (parts[0] == 'jmp') {\r\n                parts[1] = get_jmp_loc(i, parts[1])\r\n            } else if (parts[0].startsWith('split')) {\r\n                parts[1] = get_jmp_loc(i, parts[1])\r\n                parts[2] = get_jmp_loc(i, parts[2])\r\n            } else if (parts[0] == 'ignore') {\r\n                parts[1] = parseInt(parts[1])\r\n                parts[2] = parseInt(parts[2])\r\n            }\r\n            instructions.push(parts)\r\n        }\r\n        return instructions\r\n    }\r\n\r\n    function add_thread(instructions, pc, queue, content) {\r\n        let instruction = instructions[pc]\r\n        let operator = instruction[0]\r\n\r\n        switch (operator) {\r\n            case 'splitjmp':\r\n                add_thread(instructions, instruction[2], queue, content)\r\n                add_thread(instructions, instruction[1], queue, content)\r\n                break\r\n            case 'splitstay':\r\n                add_thread(instructions, instruction[1], queue, content)\r\n                add_thread(instructions, instruction[2], queue, content)\r\n                break\r\n            case 'split':\r\n                add_thread(instructions, instruction[1], queue, content)\r\n                add_thread(instructions, instruction[2], queue, content)\r\n                break\r\n            case 'jmp':\r\n                add_thread(instructions, instruction[1], queue, content)\r\n                break\r\n            case 'chr':\r\n                is_match = instruction[2] == 0 ? true : instruction[1] == (content & instruction[2])\r\n                if (is_match) {\r\n                    queue.push(pc)\r\n                }\r\n                break\r\n            case 'chrc':\r\n                let bitmap_index = (content >> 3) + 1\r\n                let bit_index = (content & 0x07)\r\n                let mask = 1 << bit_index\r\n                is_match = ((instruction[bitmap_index] & mask) != 0)\r\n                if (is_match)\r\n                    queue.push(pc)\r\n                break\r\n            default:\r\n                queue.push(pc)\r\n        }\r\n\r\n    }\r\n\r\n    function get_thread(thread_pool, pc, priority) {\r\n        let new_thread = null\r\n        if (thread_pool.length != 0) {\r\n            new_thread = thread_pool.pop()\r\n            new_thread.pc = pc\r\n            new_thread.priority = priority\r\n        } else\r\n            new_thread = {pc: pc, priority: priority}\r\n        return new_thread\r\n\r\n    }\r\n\r\n    function clear_thread_array(thread_pool, thread_array) {\r\n        thread_pool.push(...thread_array)\r\n        thread_array.length = 0\r\n    }\r\n\r\n\r\n    function find(file_content, instructions, start_index, thread_pool) {\r\n\r\n        debugger;\r\n        let current_state = []\r\n        current_state.push(get_thread(thread_pool, 0, 0))\r\n        // add_thread(instructions, 0, current_state, file_content[start_index])\r\n        let next_state = []\r\n\r\n        let c_thread = null\r\n        let c_prgcounter = 0\r\n        let op = null\r\n        let instruction = null\r\n        let is_match = false\r\n\r\n        let found_match = null\r\n\r\n        let ignore_stack = []\r\n        let ignore = null\r\n\r\n        let skip = false\r\n        for (let i = start_index; i < file_content.length; i++) {\r\n            skip = false;\r\n            for (let t = 0; t < current_state.length & skip == false; t++) {\r\n                c_prgcounter = current_state[t].pc\r\n                instruction = instructions[c_prgcounter]\r\n                op = instruction[0]\r\n                switch (op) {\r\n                    case 'chr':\r\n                        is_match = instruction[2] == 0 ? true : instruction[1] == (file_content[i] & instruction[2])\r\n                        if (is_match === false) {\r\n                            if (ignore_stack.length == 0) {\r\n                                break;\r\n                            } else {\r\n                                ignore = ignore_stack.pop()\r\n                                i = ignore.end\r\n                                c_prgcounter = ignore.ignore_loc\r\n                                ignore.end -= 1\r\n                                if (ignore.start <= ignore.end) {\r\n                                    ignore_stack.push(ignore)\r\n                                }\r\n                            }\r\n                        }\r\n                        add_priority_queue(next_state, get_thread(thread_pool, c_prgcounter + 1, current_state[t].priority))\r\n                        // add_thread(instructions, c_prgcounter + 1, next_state, file_content[i+1] )\r\n                        break;\r\n                    case 'chrc':\r\n                        let bitmap_index = (file_content[i] >> 3) + 1\r\n                        let bit_index = (file_content[i] & 0x07)\r\n                        let mask = 1 << bit_index\r\n                        is_match = ((instruction[bitmap_index] & mask) != 0)\r\n                        if (is_match === false) {\r\n                            if (ignore_stack.length == 0) {\r\n                                break;\r\n                            } else {\r\n                                ignore = ignore_stack.pop()\r\n                                i = ignore.end\r\n                                c_prgcounter = ignore.ignore_loc\r\n                                ignore.end -= 1\r\n                                if (ignore.start <= ignore.end) {\r\n                                    ignore_stack.push(ignore)\r\n                                }\r\n                            }\r\n                        }\r\n                        // next_state.push(c_prgcounter + 1)\r\n                        next_state.push(get_thread(thread_pool, c_prgcounter + 1, current_state[t].priority))\r\n                        //add_thread(instructions, c_prgcounter + 1, next_state,  file_content[i+1])\r\n                        break;\r\n                    case 'ignore':\r\n                        if (instruction[2] == -1)\r\n                            instruction[2] = file_content.length\r\n                        ignore_stack.push({\r\n                            start: i + instruction[1] - 1,\r\n                            end: i + instruction[2] - 1,\r\n                            ignore_loc: c_prgcounter\r\n                        })\r\n                        i = i + instruction[1] - 1\r\n                        // next_state.push(c_prgcounter + 1)\r\n                        add_priority_queue(next_state, get_thread(thread_pool, c_prgcounter + 1, current_state[t].priority))\r\n                        break\r\n                    case 'splitjmp':\r\n                        add_priority_queue(current_state, get_thread(thread_pool, instruction[1], current_state[t].priority))\r\n                        add_priority_queue(current_state, get_thread(thread_pool, instruction[2], current_state[t].priority + 1))\r\n                        break\r\n                    case 'splitstay':\r\n                        add_priority_queue(current_state, get_thread(thread_pool, instruction[1], current_state[t].priority + 1))\r\n                        add_priority_queue(current_state, get_thread(thread_pool, instruction[2], current_state[t].priority))\r\n                        break\r\n                    case 'split':\r\n                        add_priority_queue(current_state, get_thread(thread_pool, instruction[1], current_state[t].priority + 1))\r\n                        add_priority_queue(current_state, get_thread(thread_pool, instruction[2], current_state[t].priority))\r\n                        break\r\n                    case 'jmp':\r\n                        add_priority_queue(current_state, get_thread(thread_pool, instruction[1], current_state[t].priority))\r\n                        break\r\n\r\n                    case 'match':\r\n                        if (found_match == null)\r\n                            found_match = {\r\n                                start: start_index,\r\n                                end: i - 1,\r\n                                match: true\r\n                            }\r\n                        else {\r\n                            if (found_match.end < (i - 1)) {\r\n                                found_match = {\r\n                                    start: start_index,\r\n                                    end: i - 1,\r\n                                    match: true\r\n                                }\r\n                            }\r\n                        }\r\n                        skip = true\r\n                        break;\r\n\r\n                }\r\n            }\r\n\r\n            if (next_state.length == 0) {\r\n                if (found_match != null) {\r\n                    return found_match\r\n                }\r\n                // current_state = []\r\n                clear_thread_array(thread_pool, current_state)\r\n                start_index = i + 1\r\n                // add_thread(instructions, 0, current_state, file_content[start_index])\r\n                current_state.push(get_thread(thread_pool, 0, 0))\r\n\r\n            } else {\r\n                clear_thread_array(thread_pool, current_state)\r\n                current_state = next_state\r\n                next_state = []\r\n\r\n            }\r\n        }\r\n        return found_match\r\n    }\r\n\r\n    function add_priority_queue(queue, state) {\r\n        queue.push(state)\r\n        let state_loc = queue.length - 1\r\n        for (let i = queue.length - 2; i >= 0; i--) {\r\n            if (queue[state_loc].priority < queue[i].priority) {\r\n                let tmp = queue[state_loc];\r\n                queue[state_loc] = queue[i];\r\n                queue[i] = tmp;\r\n                state_loc = i\r\n            } else {\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function get_jmp_loc(current_loc, jump_addr) {\r\n        let final_add = jump_addr\r\n        if (jump_addr.startsWith('[')) {\r\n            final_add = jump_addr.substr(1, jump_addr.length - 2)\r\n            final_add = parseInt(final_add) + current_loc\r\n        } else\r\n            final_add = parseInt(final_add)\r\n        return final_add\r\n    }\r\n\r\n}\n\n//# sourceURL=webpack://yaradbg-frontend/./src/js/hex_exp_worker.js?");

/***/ }),

/***/ "./src/js/operators.js":
/*!*****************************!*\
  !*** ./src/js/operators.js ***!
  \*****************************/
/***/ (() => {

eval("function eval_condition(file, condition_tasks, evaluated_rule) {\r\n    debugger;\r\n    let result = null\r\n    let task = null\r\n    let evaluated_task = new Map()\r\n    for (let i = 0; i < condition_tasks.length; i++) {\r\n        task = condition_tasks[i]\r\n        result = null\r\n        if ('op' in task) {\r\n            for (let j = 0; j < task.args.length; j++) {\r\n                task.args[j] = get_arg(task.args[j], evaluated_task)\r\n            }\r\n            switch (task.op) {\r\n                case 'of':\r\n                    result = of_operator(task.args[0], task.args[1], evaluated_rule.strings)\r\n                    break\r\n                case '+':\r\n                    result = add_operator(task.args[0], task.args[1])\r\n                    break\r\n                case '==':\r\n                    result = eq_operator(task.args[0], task.args[1])\r\n                    break\r\n                case 'and':\r\n                    result = and_operator(task.args[0], task.args[1])\r\n                    break\r\n                case 'or':\r\n                    result = or_operator(task.args[0], task.args[1])\r\n                    break\r\n                case  'uint8':\r\n                case  'uint8be':\r\n                    result = integer_operator(task.args[0], file, 1)\r\n                    break\r\n                case  'uint16':\r\n                    result = integer_operator(task.args[0], file, 2)\r\n                    break\r\n                case  'uint32':\r\n                    result = integer_operator(task.args[0], file, 4)\r\n                    break\r\n                case  'uint16be':\r\n                    result = integer_operator(task.args[0], file, 2, false, false)\r\n                    break\r\n                case  'uint32be':\r\n                    result = integer_operator(task.args[0], file, 4, false, false)\r\n                    break\r\n                case  'int8':\r\n                case  'int8be':\r\n                    result = integer_operator(task.args[0], file, 1, true)\r\n                    break\r\n                case  'int16':\r\n                    result = integer_operator(task.args[0], file, 2, true)\r\n                    break\r\n                case  'int32':\r\n                    result = integer_operator(task.args[0], file, 4, true)\r\n                    break\r\n                case  'int16be':\r\n                    result = integer_operator(task.args[0], file, 2, true, false)\r\n                    break\r\n                case  'int32be':\r\n                    result = integer_operator(task.args[0], file, 4, true, false)\r\n                    break\r\n\r\n            }\r\n            if (result !== null) {\r\n                evaluated_task.set(task.id, result)\r\n                task.result = result\r\n            }\r\n        } else {\r\n            // token\r\n        }\r\n    }\r\n    debugger;\r\n}\r\n\r\nfunction get_arg(arg, evaluated_tasks) {\r\n    if (arg.name === 'Task') {\r\n        return evaluated_tasks.get(arg.val)\r\n    } else {\r\n        return arg\r\n    }\r\n}\r\n\r\nfunction of_operator(arg_left, arg_right, strings) {\r\n    let string_set = []\r\n\r\n    if (arg_left.name === 'ALL') {\r\n        arg_left = strings.size\r\n    } else {\r\n        arg_left = get_number(arg_left.val)\r\n    }\r\n\r\n    if (arg_right.name === 'THEM') {\r\n        for (let str_name of strings.keys()) {\r\n            string_set.push(str_name)\r\n        }\r\n    } else if (arg_right.name === 'STRING_IDENTIFIER_WITH_WILDCARD') {\r\n        let prefix = get_string_name(arg_right.val).slice(0, -1)\r\n        for (let str_name of strings.keys()) {\r\n            if (str_name.startsWith(prefix)) {\r\n                string_set.push(str_name)\r\n            }\r\n        }\r\n    }\r\n\r\n    let res = false\r\n    if (arg_left > 0) {\r\n        for (let i = 0; i < string_set.length; i++) {\r\n            if (strings.get(string_set[i]).length > 0) {\r\n                arg_left -= 1\r\n                if (arg_left === 0) {\r\n                    res = true\r\n                    break\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        res = true\r\n    }\r\n\r\n    return {\r\n        name: 'of_res',\r\n        value: res,\r\n        line: arg_left.line,\r\n        col: arg_left.col\r\n    }\r\n}\r\n\r\nfunction add_operator(arg_left, arg_right) {\r\n    return {\r\n        name: 'add_res',\r\n        val: get_number(arg_left.val) + get_number(arg_right.val),\r\n        line: arg_left.line,\r\n        col: arg_left.col\r\n    }\r\n}\r\n\r\nfunction and_operator(arg_left, arg_right) {\r\n    return {\r\n        name: 'and_res',\r\n        val: get_boolean(arg_left.val) && get_boolean(arg_right.val),\r\n        line: arg_left.line,\r\n        col: arg_left.col\r\n    }\r\n}\r\n\r\nfunction or_operator(arg_left, arg_right) {\r\n    return {\r\n        name: 'or_res',\r\n        val: get_boolean(arg_left.val) || get_boolean(arg_right.val),\r\n        line: arg_left.line,\r\n        col: arg_left.col\r\n    }\r\n}\r\n\r\nfunction eq_operator(arg_left, arg_right) {\r\n    let arg_left_val = get_number(arg_left.val)\r\n    if (isNaN(arg_left_val)) {\r\n        arg_left_val = arg_left.val\r\n    }\r\n\r\n    let arg_right_val = get_number(arg_right.val)\r\n    if (isNaN(arg_right_val)) {\r\n        arg_right_val = arg_right.val\r\n    }\r\n    return {\r\n        name: 'eq_res',\r\n        val: arg_left_val === arg_right_val,\r\n        line: arg_left.line,\r\n        col: arg_left.col\r\n    }\r\n}\r\n\r\nfunction integer_operator(arg_left, file, byte_count, signed = false, little_endian = true) {\r\n    debugger;\r\n    let val = undefined\r\n\r\n    let offset = parseInt(arg_left.val)\r\n    let data_view = new DataView(file.buffer, offset, byte_count)\r\n    switch (byte_count) {\r\n        case 1:\r\n            if (offset < file.length)\r\n                val = signed ? data_view.getInt8(0) : data_view.getUint8(0)\r\n            break\r\n        case 2:\r\n            if (offset < file.length - 1)\r\n                val = signed ? data_view.getInt16(0, little_endian) :\r\n                    data_view.getUint16(0, little_endian)\r\n            break\r\n        case 4:\r\n            if (offset < file.length - 3)\r\n                val = signed ? data_view.getInt32(0, little_endian) :\r\n                    data_view.getUint32(0, little_endian)\r\n            break\r\n    }\r\n    return {\r\n        name: `${signed ? \"\" : \"u\"}int${byte_count * 8}${little_endian ? \"\" : \"be\"}_res`,\r\n        val: val,\r\n        line: arg_left.line,\r\n        col: arg_left.col\r\n    }\r\n}\r\n\r\nfunction parseBool(arg) {\r\n    let res = false\r\n    if (arg === 'true')\r\n        res = true\r\n    return res\r\n}\r\n\r\nfunction get_string_name(string) {\r\n    if (string.length > 1 && (string[0] === '$' || string[0] === '#' || string[0] === '@'))\r\n        return string.slice(1)\r\n    else\r\n        return string\r\n}\r\n\r\nfunction get_number(string) {\r\n    if (typeof string == 'number')\r\n        return string\r\n    return string.startsWith('0x') ? parseInt(string, 16) : parseInt(string)\r\n}\r\n\r\nfunction get_boolean(string) {\r\n    if (typeof string == 'boolean')\r\n        return string\r\n    return parseBool(string)\r\n}\r\n\r\n\n\n//# sourceURL=webpack://yaradbg-frontend/./src/js/operators.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_modules__["./src/js/operators.js"]();
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/js/hex_exp_worker.js"]();
/******/ 	
/******/ })()
;