/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/hex_exp_worker.js":
/*!**********************************!*\
  !*** ./src/js/hex_exp_worker.js ***!
  \**********************************/
/***/ (() => {

eval("self.importScripts(\"/yaradbg-frontend/src/js/operators.js\")\r\n\r\nself.onmessage = function (e) {\r\n    data = e.data\r\n    res = match_rule(data.file, data.rule)\r\n    self.postMessage(res);\r\n}\r\n\r\nfunction match_rule(file, rule) {\r\n    let evaluated_rule = {strings:new Map(), condition: []}\r\n\r\n    Object.keys(rule).forEach(function (key) {\r\n\r\n        if (key == 'string') {\r\n            match_strings(rule[key], file, evaluated_rule.strings)\r\n        }\r\n        else if(key == 'condition')\r\n        {\r\n            eval_condition(file, rule[key], evaluated_rule)\r\n        }\r\n    });\r\n\r\n    return evaluated_rule\r\n}\r\n\r\n\r\n\r\nfunction match_strings(strings, file, rule_result) {\r\n\r\n    let matches = null\r\n    for(let i=0; i<strings.length; i++){\r\n        rule_result.set(strings[i].str_name.slice(1), [])\r\n    }\r\n    for (const index in strings) {\r\n        let string = strings[index]\r\n\r\n        if (string.type == 'hex_exp_bytecode' ||\r\n            string.type == 'regex_expression_bytecode') {\r\n            matches = find_all(file, string.val)\r\n            if (matches != null) {\r\n                for (let i = 0; i < matches.length; i++) {\r\n                    rule_result.get(string.str_name.slice(1)).push({string: string, start: matches[i].start, end: matches[i].end})\r\n                }\r\n            }\r\n        } else if (string.type == 'literal_string') {\r\n\r\n            let nocase = false,\r\n                ascii = false,\r\n                wide = false;\r\n            for (let i = 0; i < string.modifiers.length; i++) {\r\n                switch (string.modifiers[i].modifier) {\r\n                    case 'nocase':\r\n                        nocase = true;\r\n                        break\r\n                    case 'ascii':\r\n                        ascii = true;\r\n                        break\r\n                    case 'wide':\r\n                        wide = true;\r\n                }\r\n            }\r\n            if (wide == false)\r\n                ascii = true\r\n\r\n            let bytecode = []\r\n            string.val = string.val.substr(1, string.val.length - 2)\r\n\r\n            for (let i = 0; i < string.val.length; i++) {\r\n                bytecode.push(`chr ${string.val.charCodeAt(i).toString(16)}`)\r\n            }\r\n            bytecode.push('match')\r\n\r\n            matches = find_all(file, bytecode)\r\n            if (matches != null) {\r\n                for (let i = 0; i < matches.length; i++) {\r\n                    rule_result.get(string.str_name.slice(1)).push({string: string, start: matches[i].start, end: matches[i].end})\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    return matches\r\n}\r\n\r\nfunction find_all(file_content, regex_bytecode) {\r\n    let index = 0\r\n    let matches = []\r\n    let match = null\r\n\r\n    let instructions = get_instructions(regex_bytecode)\r\n    let parts = []\r\n    let has_start_mask, has_end_mask;\r\n    var lookahead = null\r\n\r\n    if (instructions[0][0] == 'chr')\r\n        lookahead = instructions[0][1]\r\n\r\n    let thread_pool = []\r\n    for(let i = 0 ; i< 10; i++)\r\n    {\r\n        thread_pool.push({pc: 0, priority: 0})\r\n    }\r\n\r\n    let start = performance.now()\r\n    while (index < file_content.length) {\r\n        match = find(file_content, instructions, index, thread_pool)\r\n        if (match != null) {\r\n            index = match.start + 1\r\n            matches.push(match)\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n    let end = performance.now()\r\n    let diff = (end - start).toString()\r\n\r\n    return matches\r\n}\r\n\r\nfunction get_instructions(bytecode) {\r\n    debugger;\r\n    let instructions = []\r\n    let lines = bytecode\r\n    let has_start_mask = false\r\n    let has_end_mask = false\r\n    let parts = null\r\n\r\n    for (let i = 0; i < lines.length; i++) {\r\n        parts = lines[i].split(/[ ,]/)\r\n        if (parts[0] == 'chr') {\r\n            has_start_mask =  parts[1].startsWith('?')? 0 : 0x0f\r\n            has_end_mask = parts[1].endsWith('?')? 0 : 0xf0\r\n            parts[1] = parseInt(parts[1].replace('?', '0'), 16)\r\n            parts.push(has_end_mask | has_start_mask)\r\n        } else if (parts[0] == 'chrc') {\r\n            for(let i=1; i<parts.length; i++){\r\n                parts[i] = parseInt(parts[i], 16)\r\n            }\r\n        } else if (parts[0] == 'jmp') {\r\n            parts[1] = get_jmp_loc(i, parts[1])\r\n        } else if (parts[0].startsWith('split'))  {\r\n            parts[1] = get_jmp_loc(i, parts[1])\r\n            parts[2] = get_jmp_loc(i, parts[2])\r\n        } else if (parts[0] == 'ignore') {\r\n            parts[1] = parseInt(parts[1])\r\n            parts[2] = parseInt(parts[2])\r\n        }\r\n        instructions.push(parts)\r\n    }\r\n    return instructions\r\n}\r\n\r\nfunction add_thread(instructions, pc, queue, content){\r\n    let instruction = instructions[pc]\r\n    let operator = instruction[0]\r\n\r\n    switch(operator){\r\n        case 'splitjmp':\r\n            add_thread(instructions, instruction[2], queue, content)\r\n            add_thread(instructions, instruction[1], queue, content)\r\n            break\r\n        case 'splitstay':\r\n            add_thread(instructions, instruction[1], queue, content)\r\n            add_thread(instructions, instruction[2], queue, content)\r\n            break\r\n        case 'split':\r\n            add_thread(instructions, instruction[1], queue, content)\r\n            add_thread(instructions, instruction[2], queue, content)\r\n            break\r\n        case 'jmp':\r\n            add_thread(instructions, instruction[1], queue, content)\r\n            break\r\n        case 'chr':\r\n            is_match = instruction[2] == 0 ? true : instruction[1] == (content & instruction[2])\r\n            if(is_match) {\r\n                queue.push(pc)\r\n            }\r\n            break\r\n        case 'chrc':\r\n            let bitmap_index = (content >> 3) + 1\r\n            let bit_index = (content& 0x07)\r\n            let mask = 1 << bit_index\r\n            is_match = ((instruction[bitmap_index] & mask) != 0)\r\n            if (is_match )\r\n                queue.push(pc)\r\n            break\r\n        default:\r\n            queue.push(pc)\r\n    }\r\n\r\n}\r\n\r\nfunction get_thread(thread_pool, pc, priority)\r\n{\r\n    let new_thread = null\r\n    if(thread_pool.length != 0) {\r\n        new_thread = thread_pool.pop()\r\n        new_thread.pc = pc\r\n        new_thread.priority = priority\r\n    }\r\n    else\r\n        new_thread = { pc:pc , priority:priority}\r\n    return new_thread\r\n\r\n}\r\n\r\nfunction clear_thread_array(thread_pool, thread_array){\r\n    thread_pool.push(...thread_array)\r\n    thread_array.length = 0\r\n}\r\n\r\n\r\nfunction find(file_content, instructions, start_index, thread_pool) {\r\n\r\n    debugger;\r\n    let current_state = []\r\n    current_state.push(get_thread(thread_pool, 0, 0))\r\n    // add_thread(instructions, 0, current_state, file_content[start_index])\r\n    let next_state = []\r\n\r\n    let c_thread = null\r\n    let c_prgcounter = 0\r\n    let op = null\r\n    let instruction = null\r\n    let is_match = false\r\n\r\n    let found_match = null\r\n\r\n    let ignore_stack = []\r\n    let ignore = null\r\n\r\n    let skip = false\r\n    for (let i = start_index; i < file_content.length; i++) {\r\n        skip = false;\r\n        for (let t = 0; t < current_state.length & skip == false; t++) {\r\n            c_prgcounter = current_state[t].pc\r\n            instruction = instructions[c_prgcounter]\r\n            op = instruction[0]\r\n            switch (op) {\r\n                case 'chr':\r\n                    is_match = instruction[2] == 0 ? true : instruction[1] == (file_content[i] & instruction[2])\r\n                    if (is_match === false) {\r\n                        if (ignore_stack.length == 0) {\r\n                            break;\r\n                        } else {\r\n                            ignore = ignore_stack.pop()\r\n                            i = ignore.end\r\n                            c_prgcounter = ignore.ignore_loc\r\n                            ignore.end -= 1\r\n                            if (ignore.start <= ignore.end) {\r\n                                ignore_stack.push(ignore)\r\n                            }\r\n                        }\r\n                    }\r\n                    add_priority_queue(next_state,get_thread(thread_pool, c_prgcounter + 1, current_state[t].priority))\r\n                    // add_thread(instructions, c_prgcounter + 1, next_state, file_content[i+1] )\r\n                    break;\r\n                case 'chrc':\r\n                    let bitmap_index = (file_content[i] >> 3) + 1\r\n                    let bit_index = (file_content[i] & 0x07)\r\n                    let mask = 1 << bit_index\r\n                    is_match = ((instruction[bitmap_index] & mask) != 0)\r\n                    if (is_match === false) {\r\n                        if (ignore_stack.length == 0) {\r\n                            break;\r\n                        } else {\r\n                            ignore = ignore_stack.pop()\r\n                            i = ignore.end\r\n                            c_prgcounter = ignore.ignore_loc\r\n                            ignore.end -= 1\r\n                            if (ignore.start <= ignore.end) {\r\n                                ignore_stack.push(ignore)\r\n                            }\r\n                        }\r\n                    }\r\n                    // next_state.push(c_prgcounter + 1)\r\n                    next_state.push(get_thread(thread_pool, c_prgcounter + 1, current_state[t].priority))\r\n                    //add_thread(instructions, c_prgcounter + 1, next_state,  file_content[i+1])\r\n                    break;\r\n                case 'ignore':\r\n                    if (instruction[2] == -1)\r\n                        instruction[2] = file_content.length\r\n                    ignore_stack.push({\r\n                        start: i + instruction[1] - 1,\r\n                        end: i + instruction[2] - 1,\r\n                        ignore_loc: c_prgcounter\r\n                    })\r\n                    i = i + instruction[1] - 1\r\n                    // next_state.push(c_prgcounter + 1)\r\n                    add_priority_queue(next_state,get_thread(thread_pool, c_prgcounter + 1, current_state[t].priority))\r\n                    break\r\n                case 'splitjmp':\r\n                    add_priority_queue(current_state, get_thread(thread_pool, instruction[1], current_state[t].priority))\r\n                    add_priority_queue(current_state, get_thread(thread_pool, instruction[2], current_state[t].priority+1))\r\n                    break\r\n                case 'splitstay':\r\n                    add_priority_queue(current_state, get_thread(thread_pool, instruction[1], current_state[t].priority+1))\r\n                    add_priority_queue(current_state, get_thread(thread_pool, instruction[2], current_state[t].priority))\r\n                    break\r\n                case 'split':\r\n                    add_priority_queue(current_state, get_thread(thread_pool, instruction[1], current_state[t].priority+1))\r\n                    add_priority_queue(current_state, get_thread(thread_pool, instruction[2], current_state[t].priority))\r\n                    break\r\n                case 'jmp':\r\n                    add_priority_queue(current_state, get_thread(thread_pool, instruction[1], current_state[t].priority))\r\n                    break\r\n\r\n                case 'match':\r\n                    if (found_match == null)\r\n                        found_match = {\r\n                            start: start_index,\r\n                            end: i - 1,\r\n                            match: true\r\n                        }\r\n                    else {\r\n                        if (found_match.end < (i - 1)) {\r\n                            found_match = {\r\n                                start: start_index,\r\n                                end: i - 1,\r\n                                match: true\r\n                            }\r\n                        }\r\n                    }\r\n                    skip = true\r\n                    break;\r\n\r\n            }\r\n        }\r\n\r\n        if (next_state.length == 0) {\r\n            if (found_match != null) {\r\n                return found_match\r\n            }\r\n            // current_state = []\r\n            clear_thread_array(thread_pool, current_state)\r\n            start_index = i + 1\r\n            // add_thread(instructions, 0, current_state, file_content[start_index])\r\n            current_state.push(get_thread(thread_pool, 0, 0))\r\n\r\n        } else {\r\n            clear_thread_array(thread_pool, current_state)\r\n            current_state = next_state\r\n            next_state = []\r\n\r\n        }\r\n    }\r\n    return found_match\r\n}\r\n\r\nfunction add_priority_queue(queue, state){\r\n    queue.push(state)\r\n    let state_loc = queue.length -1\r\n    for(let i=queue.length -2; i>=0; i--)\r\n    {\r\n        if(queue[state_loc].priority < queue[i].priority)\r\n        {\r\n            let tmp = queue[state_loc];\r\n            queue[state_loc] = queue[i];\r\n            queue[i]= tmp;\r\n            state_loc = i\r\n        }\r\n        else{\r\n            break\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction get_jmp_loc(current_loc, jump_addr) {\r\n    let final_add = jump_addr\r\n    if (jump_addr.startsWith('[')) {\r\n        final_add = jump_addr.substr(1, jump_addr.length - 2)\r\n        final_add = parseInt(final_add) + current_loc\r\n    } else\r\n        final_add = parseInt(final_add)\r\n    return final_add\r\n}\n\n//# sourceURL=webpack://yaradbg-frontend/./src/js/hex_exp_worker.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/js/hex_exp_worker.js"]();
/******/ 	
/******/ })()
;